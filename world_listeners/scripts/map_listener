#!/usr/bin/env python

'''
The map_listener node listens to a specified OccupancyGrid message
and updates the world model accordingly.

@author:  Russell Toris
@version: January 17, 2013
'''

import rospy
from nav_msgs.msg import OccupancyGrid
from world_msgs.srv import UpdateWorldModel
from world_msgs.msg import WorldModelEntity, WorldModelObservation
from geometry_msgs.msg import Point32

def map_cb(message, args):
    '''
    Main callback for a map topic. This will insert a new entity in the world model
    or update an existing entity if one exists with the same name. 
    
    @param message: the ROS message for the map
    @type  message: OccupancyGrid
    @param args: the topic name we are listening on and name-space for this node
    @type  topic: dict
    '''
    entity = WorldModelEntity()
    
    # break up the message and store it
    entity.frame_id = args['ns'] + '_map'
    
    entity.pose.pose.pose = message.info.origin
    entity.pose.header.stamp = message.header.stamp
    
    # add the bounding box
    p0 = Point32()
    p0.x = message.info.origin.position.x
    p0.y = message.info.origin.position.y
    p0.z = message.info.origin.position.z
    p1 = Point32()
    p1.x = message.info.origin.position.x + (message.info.resolution * message.info.width)
    p1.y = message.info.origin.position.y
    p1.z = message.info.origin.position.z
    p2 = Point32()
    p2.x = message.info.origin.position.x + (message.info.resolution * message.info.width)
    p2.y = message.info.origin.position.y + (message.info.resolution * message.info.height)
    p2.z = message.info.origin.position.z
    p3 = Point32()
    p3.x = message.info.origin.position.x
    p3.y = message.info.origin.position.y + (message.info.resolution * message.info.height)
    p3.z = message.info.origin.position.z
    entity.description.bbox.points.append(p0)
    entity.description.bbox.points.append(p1)
    entity.description.bbox.points.append(p2)
    entity.description.bbox.points.append(p3)
    
    observation = WorldModelObservation()
    observation.type = 'topic'
    observation.ref = args['topic']
    entity.observations.append(observation)
    
    entity.tags.append('robot')
    entity.tags.append(args['ns'])

    # create a handle and do the update
    update_world = rospy.ServiceProxy('/world_model/update_world_model', UpdateWorldModel)
    update_world(entity)

def main():
    '''
    The main run function for the map_listener node.
    '''
    rospy.init_node('map_listener')
    # wait for the world model node
    rospy.loginfo('Waiting for /world_model/update_world_model to become available...')
    rospy.wait_for_service('/world_model/update_world_model')
    
    # check for a topic to listen on
    t = rospy.get_param('~topic', '/map')
    ns = rospy.get_param('~ns', 'my_robot')
    # subscribe to the topic with a queue size of 1
    rospy.Subscriber(t, OccupancyGrid, map_cb, {'topic' : t, 'ns' : ns}, 1)
    
    rospy.loginfo('Map Listener is Ready!')
    rospy.spin()


if __name__ == '__main__':
    main()
