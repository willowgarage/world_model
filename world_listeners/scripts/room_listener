#!/usr/bin/env python

# Software License Agreement (BSD License)
#
# Copyright (c) 2013, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
# * Neither the name of Willow Garage, Inc. nor the names of its
# contributors may be used to endorse or promote products derived
# from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

'''
The room_listener node listens for PolygonWithPose messages and tags them as rooms
inside the namespace's internal map.

@author:  Russell Toris
@version: January 23, 2013
'''

import rospy
from world_msgs.srv import *
from world_msgs.msg import *
import socket

def polygon_cb(message, args):
    '''
    Main callback for a polygon with pose topic. This will insert a new entity in the world object 
    instance database or update an existing entity if one exists with the same position. 
    
    @param message: the ROS message for the pose/polygon
    @type  message: PolygonWithPose
    @param args: the topic name we are listening on and name-space for this node
    @type  topic: dict
    '''
    # break up the message and store it
    instance = WorldObjectInstance()

    # source information for this node
    instance.source.origin = socket.gethostname()
    instance.source.creator = 'room_listener'
    
    # position information
    instance.pose.pose.pose = message.pose
    # get our map ID
    search = rospy.ServiceProxy('/world_model/search_world_object_instance_tags',
                                WorldObjectInstanceTagSearch)
    resp = search(['map', args['ns']])
    if(len(resp.instances) > 0):
        # check if we only found one (which should be the case)
        if(len(resp.instances) > 1):
            rospy.logwarn('Multiple world object instances tagged with "map" and "' + ns + 
                          '". Defaulting to first result.')
        # assign the ID
        instance.pose.header.frame_id = resp.instances[0].instance_id
    instance.pose.header.stamp = rospy.get_rostime()
    
    # tag this as a room
    instance.tags = ['room', args['ns']]
    
    # check if we already have a room with that pose and just update it
    update = False
    resp = search(instance.tags)
    for i in resp.instances:
        # check the pose information
        if(i.pose.pose.pose == message.pose):
            # create a handle and do the update
            update = rospy.ServiceProxy('/world_model/update_world_object_instance',
                                        UpdateWorldObjectInstance)
            update(resp.instances[0].instance_id, instance)
            return
    
    # no match found -- new instance
    instance.name = args['ns'] + ' Un-named Room'
    # room usually last a long time (six months)
    instance.expected_ttl = rospy.Duration(60 * 60 * 24 * 178)

    # create a handle and do the creation
    create = rospy.ServiceProxy('/world_model/create_world_object_instance',
                                CreateWorldObjectInstance)
    create(instance)

def main():
    '''
    The main run function for the room_listener node.
    '''
    rospy.init_node('room_listener')
    # wait for the world model node
    rospy.loginfo('Waiting for /world_model/create_world_object_instance to become available...')
    rospy.wait_for_service('/world_model/create_world_object_instance')
    rospy.loginfo('Waiting for /world_model/update_world_object_instance to become available...')
    rospy.wait_for_service('/world_model/update_world_object_instance')
    rospy.loginfo('Waiting for /world_model/search_world_object_instance_tags to become available...')
    rospy.wait_for_service('/world_model/search_world_object_instance_tags')
    
    # check for a topic to listen on
    t = rospy.get_param('~topic', '/rooms')
    ns = rospy.get_param('~ns', 'my_robot')

    # subscribe to the topic
    rospy.Subscriber(t, PolygonWithPose, polygon_cb, {'ns' : ns})
    
    rospy.loginfo('Room Listener is Ready!')
    rospy.spin()

if __name__ == '__main__':
    main()
