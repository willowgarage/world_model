#!/usr/bin/env python

# Software License Agreement (BSD License)
#
# Copyright (c) 2013, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
# * Neither the name of Willow Garage, Inc. nor the names of its
# contributors may be used to endorse or promote products derived
# from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

'''
The world_model node exposes the worldlib API over ROS topics and services.

@author:  Russell Toris
@version: February 4, 2013
'''

import rospy
import actionlib
from worldlib import world_object_instance_database, world_object_description_database
from worldlib.msg import *
from world_msgs.msg import WorldObjectInstance, WorldObjectDescription
from rospy_message_converter import message_converter

class WorldModel(object):
    '''
    The main WorldModel object which bridges the worldlib API to ROS action servers.
    '''
    
    def __init__(self):
        '''
        Creates and starts all action servers for the world model.
        '''
        # the connection to the databases
        self._woid = world_object_instance_database.WorldObjectInstanceDatabase()
        self._wodd = world_object_description_database.WorldObjectDescriptionDatabase()
        # advertise the action servers
        self._cwoi = actionlib.ActionServer('/world_model/create_world_object_instance',
                                            CreateWorldObjectInstanceAction,
                                            self.create_world_object_instance,
                                            auto_start=False)
        self._uwoi = actionlib.ActionServer('/world_model/update_world_object_instance',
                                            UpdateWorldObjectInstanceAction,
                                            self.update_world_object_instance,
                                            auto_start=False)
        self._woits = actionlib.ActionServer('/world_model/world_object_instance_tag_search',
                                             WorldObjectInstanceTagSearchAction,
                                             self.world_object_instance_tag_search,
                                             auto_start=False)
        self._cwod = actionlib.ActionServer('/world_model/create_world_object_description',
                                            CreateWorldObjectDescriptionAction,
                                            self.create_world_object_description,
                                            auto_start=False)
        self._gwod = actionlib.ActionServer('/world_model/get_world_object_description',
                                            GetWorldObjectDescriptionAction,
                                            self.get_world_object_description,
                                            auto_start=False)
        # start the action servers
        self._cwoi.start()
        self._uwoi.start()
        self._woits.start()
        self._cwod.start()
        self._gwod.start()
        rospy.loginfo('World Model Node is Ready')

    def create_world_object_instance(self, gh):
        '''
        The create_world_object_instance action server will create a new instance in the world 
        object instance database. A unique instance_id will be assigned and the creation time will 
        be set.
        
        @param gh: the goal handle containing the instance to insert into the database
        @type  gh: ServerGoalHandle
        '''
        gh.set_accepted()
        goal = gh.get_goal()
        # update the times
        t = rospy.get_rostime()
        goal.instance.creation = t
        goal.instance.update = t
        # convert to a dict and insert
        instance_id = self._woid.insert(message_converter.convert_ros_message_to_dictionary(goal.instance))
        # put the instance_id into the response
        result = CreateWorldObjectInstanceResult(instance_id)
        # send the response
        gh.set_succeeded(result, 'Success')
    
    def update_world_object_instance(self, gh):
        '''
        The update_world_object_instance action server will update an instance in the world object 
        instance database. The update time will be set to the current time. The instance_id cannot 
        be updated with this request.
        
        @param gh: the goal handle containing the instance to update in the database
        @type  gh: ServerGoalHandle
        '''
        gh.set_accepted()
        goal = gh.get_goal()
        # update the update time
        goal.instance.update = rospy.get_rostime()
        # make sure to set the instance_id so it cannot be changed
        goal.instance.instance_id = goal.instance_id
        # convert to a dict and update
        success = self._woid.update_entity_by_instance_id(goal.instance_id,
                                                          message_converter.convert_ros_message_to_dictionary(goal.instance))
        if success is not True:
            rospy.logwarn(goal.instance_id + ' could not be updated.')
            response = goal.instance_id + ' could not be updated. Is the instance_id valid?'
        else:
            response = 'Success'
        # put the result into the response
        result = UpdateWorldObjectInstanceResult(success)
        # send the response
        gh.set_succeeded(result, response)
        
    def world_object_instance_tag_search(self, gh):
        '''
        The world_object_instance_tag_search action server will search for all instances in the 
        database that have the given list of tags.
        
        @param gh: the goal containing the instance to update in the database
        @type  gh: ServerGoalHandle
        '''
        gh.set_accepted()
        goal = gh.get_goal()
        # search for all of the tags
        entities = self._woid.search_tags(goal.tags)
        instances = []
        # parse out the data
        for e in entities:
            del e['_id']
            instances.append(message_converter.convert_dictionary_to_ros_message('world_msgs/WorldObjectInstance', e))
        # put the instances into the response
        result = WorldObjectInstanceTagSearchResult(instances)
        # send the response
        gh.set_succeeded(result, 'Success')

    def create_world_object_description(self, gh):
        '''
        The create_world_object_description action server will create a new description in the world 
        object description database. A unique description_id will be assigned.
        
        @param gh: the goal handle containing the description to insert into the database
        @type  gh: ServerGoalHandle
        '''
        gh.set_accepted()
        goal = gh.get_goal()
        # convert to a dict and insert
        description_id = self._wodd.insert(message_converter.convert_ros_message_to_dictionary(goal.description))
        # put the description_id into the response
        result = CreateWorldObjectDescriptionResult(description_id)
        # send the response
        gh.set_succeeded(result, 'Success')
        
    def get_world_object_description(self, gh):
        '''
        The get_world_object_description action server will search for and return a world object 
        description with the given description_id.
        
        @param gh: the goal handle containing the description_id to get
        @type  gh: ServerGoalHandle
        '''
        gh.set_accepted()
        goal = gh.get_goal()
        # make a request through the API
        entity = self._wodd.search_description_id(goal.description_id)
        # if a result was found, parse out the data
        exists = entity is not None
        description = WorldObjectDescription()
        if exists:
            description = message_converter.convert_dictionary_to_ros_message('world_msgs/WorldObjectDescription', entity)
            response = 'Success'
        else:
            response = goal.description_id + ' not found.'
        # put the result into the response
        result = GetWorldObjectDescriptionResult(description, exists)
        # send the response
        gh.set_succeeded(result, response)

def main():
    '''
    The main run function for the world_model node.
    '''
    rospy.init_node('world_model')
    # create the object to handle everything
    WorldModel()
    rospy.spin()

if __name__ == '__main__':
    main()
